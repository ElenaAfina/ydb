# Векторный индекс — быстрый старт

Эта статья поможет быстро начать работу с векторными индексами в YDB на простейшем модельном примере.

В статье будут рассмотрены основные шаги:

* [создание таблицы, содержащей векторы](#step1);

* [заполнение таблицы (включая колонку с векторами)](#step2);

* [построение векторного индекса](#step3);

* [выполнение векторного поиска без индекса](#step4);

* [выполнение векторного поиска с индексом](#step5).

## Шаг 1. Создание таблицы {#step1}

Сначала нужно создать таблицу в YDB, в которой будут храниться векторы. Это можно сделать следующим SQL-запросом:

```yql
CREATE TABLE Vectors (
  id Uint64,
  embedding String,
  PRIMARY KEY (id)
);
```

Эта таблица `Vectors` имеет два столбца: `id` (уникальный идентификатор каждого вектора) и `embedding` (сюда будут записаны вектора вещественных чисел, [сконвертированные в строки](https://ydb.tech/docs/ru/yql/reference/udf/list/knn?version=main#functions-convert)).

## Шаг 2. Заполнение таблицы данными {#step2}

После создания таблицы следует добавить в нее векторы следующей командой `UPSERT INTO`:

```yql
UPSERT INTO Vectors(id, embedding)
VALUES 
    (1, Untag(Knn::ToBinaryStringFloat([1.f, 1.f, 1.f, 1.f, 1.f]), "FloatVector")),
    (2, Untag(Knn::ToBinaryStringFloat([1.f, 1.f, 1.f, 1.f, 1.25f]), "FloatVector")),
    (3, Untag(Knn::ToBinaryStringFloat([1.f, 1.f, 1.f, 1.f, 1.5f]), "FloatVector")),
    (4, Untag(Knn::ToBinaryStringFloat([-1.f, -1.f, -1.f, -1.f, -1.f]), "FloatVector")),
    (5, Untag(Knn::ToBinaryStringFloat([-2.f, -2.f, -2.f, -2.f, -4.f]), "FloatVector")),
    (6, Untag(Knn::ToBinaryStringFloat([-3.f, -3.f, -3.f, -3.f, -6.f]), "FloatVector"));
```

## Шаг 3. Построение векторного индекса {#step3}

Для создания векторного индекса `Index` на таблице `Vectors` нужно использовать следующую команду:

```yql
ALTER TABLE Vectors
ADD INDEX Index
GLOBAL USING vector_kmeans_tree 
ON (embedding)
WITH (distance=cosine, vector_type="float", vector_dimension=5, levels=1, clusters=2)
```

Данная команда создает индекс типа `vector_kmeans_tree`, подробнее о векторах такого типа вы можете прочитать [здесь](../../dev/vector-indexes?version=main#kmeans-tree-type). В данном модельном примере указан параметр `clusters=2` (разбивать множество векторов при построении индекса на два кластера на каждом уровне), для реальных данных рекомендованы значения `64-512`.

Общую информацию о векторных индексах, параметрах их создания и текущих ограничениях см. в разделе [Векторные индексы](../../dev/vector-indexes?version=main).

## Шаг 4. Поиск в таблице без использования векторного индекса {#step4}

На данном шаге выполняется точный поиск 3-х ближайших соседей для заданного вектора `[1.f, 1.f, 1.f, 1.f, 4.f]` без использования индекса.

Сначала целевой вектор кодируется в бинарное представление с помощью `Knn::ToBinaryStringFloat`.

Затем вычисляется косинусное расстояние от `embedding` каждой строки до целевого вектора.

Записи сортируются по увеличению расстояния, выбираются три ближайших.

```yql
$K = 3;
$TargetEmbedding = Knn::ToBinaryStringFloat([1.f, 1.f, 1.f, 1.f, 4.f]);

SELECT id, Knn::CosineDistance(embedding, $TargetEmbedding) As CosineDistance
FROM Vectors
ORDER BY Knn::CosineDistance(embedding, $TargetEmbedding)
LIMIT $K;
```

Результат выполнения запроса:

```bash
id CosineDistance
3  0.1055728197
2  0.1467181444
1  0.1999999881
```

Подробную информацию о точном векторном поиске без использования векторных индексов см. [тут](../../yql/reference/udf/list/knn?version=main).

## Шаг 5. Поиск в таблице с использованием векторного индекса {#step5}

Для поиска 3-х ближайших соседей вектора `[1.f, 1.f, 1.f, 1.f, 4.f]` с использованием индекса `Index`, который был создан на [шаге 3](#step3) нужно выполнить следующий запрос:

```yql
$K = 3;
$TargetEmbedding = Knn::ToBinaryStringFloat([1.f, 1.f, 1.f, 1.f, 4.f]);

SELECT id, Knn::CosineDistance(embedding, $TargetEmbedding) As CosineDistance
FROM Vectors VIEW Index
ORDER BY Knn::CosineDistance(embedding, $TargetEmbedding)
LIMIT $K;
```

Результат выполнения запроса:

```bash
id CosineDistance
3  0.1055728197
2  0.1467181444
1  0.1999999881
```

Благодаря использованию индекса поиск ближайших векторов происходит значительно быстрее на больших подборках.

## Заключение

Данная статья приводит простой пример работы с векторным индексом: создание таблицы с векторами, заполнение таблицы векторами, построение векторного индекса для такой таблицы и поиск вектора в таблице с использованием векторного индекса или без него.

В случае маленькой таблицы, как в этом модельном примере, невозможно увидеть разницу в производительности запросов. Эти примеры призваны проиллюстрировать синтаксис при работе с векторными индексами. Более реалистичный пример с бОльшим объемом данных см. [тут](vector-index-with-prepared-dataset.md).

Более подробную информацию о векторных индексах см. [тут](../../dev/vector-indexes?version=main).